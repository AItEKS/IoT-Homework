# Arduino: Продвинутая работа с таймерами и прерываниями

Этот проект демонстрирует несколько ключевых концепций программирования микроконтроллеров Arduino (ATmega328P), которые выходят за рамки базовых функций `delay()` и `loop()`. Основное внимание уделяется использованию 8-битного таймера `Timer2` для создания точных по времени, неблокирующих событий.

## Задача 1: Blink по прерыванию таймера

**Цель:** Заставить светодиод мигать с заданным периодом, не используя `delay()` и не блокируя основной цикл `loop()`.

**Концепция:**
1.  **Аппаратный таймер:** Используется 8-битный `Timer2`, который аппаратно считает от 0 до 255.
2.  **Предделитель (Prescaler):** Тактовая частота МК (16 МГц) слишком высока. Мы замедляем таймер с помощью максимального предделителя `1024`. Частота тиков таймера становится `16,000,000 / 1024 = 15,625 Гц`.
3.  **Прерывание по переполнению (Overflow Interrupt):** Когда таймер досчитывает до 255 и сбрасывается в 0, он генерирует прерывание. Это происходит с частотой `15,625 / 256 ≈ 61 Гц` (каждые ~16.4 мс).
4.  **Программный счетчик:** 16.4 мс — слишком быстрый период для видимого мигания. Поэтому в обработчике прерывания (`ISR`) мы заводим программный счетчик. Мы переключаем светодиод только тогда, когда счетчик достигнет нужного значения (например, 31 для получения периода ~500 мс).

**Реализация:**
-   В `setup()` настраивается `Timer2` в режиме "Normal" и устанавливается предделитель `1024` (биты `CS22`, `CS21`, `CS20` в регистре `TCCR2B`).
-   Разрешается прерывание по переполнению (бит `TOIE2` в `TIMSK2`).
-   В `ISR(TIMER2_OVF_vect)` увеличивается счетчик. При достижении порога состояние светодиода инвертируется, а счетчик сбрасывается.
-   `loop()` остается свободным для других задач.

---

## Задача 2: Реализация собственной функции `millis()`

**Цель:** Создать функцию `my_millis()`, которая работает аналогично стандартной `millis()`, подсчитывая миллисекунды с момента запуска программы.

**Концепция:**
1.  **Точный интервал:** Нам нужно прерывание, которое срабатывает ровно 1000 раз в секунду (каждую 1 мс).
2.  **Режим CTC (Clear Timer on Compare Match):** `Timer2` настраивается в режим CTC. В этом режиме таймер считает не до 255, а до значения, записанного в регистр `OCR2A`. Когда счетчик `TCNT2` достигает значения `OCR2A`, он сбрасывается в 0 и генерирует прерывание.
3.  **Расчет `OCR2A`:** Мы подбираем значение `OCR2A` и предделитель так, чтобы прерывание происходило с частотой 1 кГц.
    -   Формула: `Частота прерывания = F_CPU / (Предделитель * (OCR2A + 1))`
    -   Для предделителя `64`: `1000 = 16,000,000 / (64 * (OCR2A + 1))`. Отсюда `OCR2A = 249`.
4.  **Атомарный доступ:** Глобальный счетчик миллисекунд (`total_millis_count`) — это `unsigned long` (4 байта). Его чтение или запись может быть прервано. Чтобы избежать гонки данных, при чтении значения в функции `my_millis()` мы временно отключаем прерывания (`cli()`), копируем значение, и включаем их обратно (`sei()` или восстановление `SREG`).

**Реализация:**
-   В `setup()` `Timer2` настраивается в режим CTC (бит `WGM21`), устанавливается предделитель `64` (бит `CS22`), и в `OCR2A` записывается `249`.
-   Разрешается прерывание по совпадению (бит `OCIE2A` в `TIMSK2`).
-   В `ISR(TIMER2_COMPA_vect)` глобальный счетчик просто увеличивается на 1.
-   Функция `my_millis()` безопасно возвращает значение этого счетчика.

---

## Задача 3: Три режима Blink с переключением по UART

**Цель:** Реализовать три разных способа мигания светодиодом, переключаемых командами `'0'`, `'1'`, `'2'`, отправляемыми через Serial порт.

**Режимы:**
1.  **Режим 0 (ISR Blink):** Фоновое мигание по прерыванию таймера, как в Задаче 1. `loop()` только отображает состояние.
2.  **Режим 1 (Millis Blink):** Неблокирующее мигание с использованием стандартной функции `millis()`. Это "правильный" способ реализации задач по времени в `loop()`.
3.  **Режим 2 (Delay Blink):** Классическое мигание с использованием блокирующей функции `delay()`. Программа "зависает" на время задержки.

**Реализация:**
-   Глобальная переменная `current_mode` хранит текущий режим.
-   В `loop()` происходит проверка `Serial.available()`. При получении команды `current_mode` меняется.
-   Основная часть `loop()` — это `switch (current_mode)`, который выполняет логику, соответствующую текущему режиму.

---

## Задача 4: Опрос аналогового пина по таймеру

**Цель:** Считывать значение с аналогового пина (например, A0) каждые 250 мс, не используя `delay()`.

**Концепция:**
Подход очень похож на Задачу 1. Мы используем то же прерывание по переполнению `Timer2`, которое происходит каждые ~16.4 мс.

1.  **Расчет счетчика:** Чтобы получить интервал 250 мс, нам нужно `250 / 16.4 ≈ 15` переполнений.
2.  **Флаг:** Функция `analogRead()` может быть довольно медленной. Выполнять ее внутри `ISR` — плохая практика. Вместо этого, когда `ISR` насчитывает нужное количество переполнений, он не выполняет чтение, а просто устанавливает **флаг** (глобальную `volatile bool` переменную).
3.  **Опрос флага в `loop()`:** Основной цикл `loop()` постоянно проверяет этот флаг. Если флаг установлен, `loop()` выполняет `analogRead()`, выводит данные в Serial, а затем сбрасывает флаг.

**Реализация:**
-   Настройка таймера идентична Задаче 1.
-   В `ISR(TIMER2_OVF_vect)` программный счетчик сравнивается со значением `15`. При достижении порога устанавливается флаг `g_analog_read_flag = true`.
-   В `loop()` есть блок `if (g_analog_read_flag)` для выполнения медленных операций.